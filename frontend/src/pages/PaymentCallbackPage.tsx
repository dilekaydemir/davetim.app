import React, { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Loader2, CheckCircle, XCircle, AlertCircle } from 'lucide-react';
import { paymentService } from '../services/paymentService';
import { subscriptionService } from '../services/subscriptionService';
import { useAuthStore } from '../store/authStore';
import toast from 'react-hot-toast';

/**
 * Convert technical error messages to user-friendly Turkish messages
 */
const getUserFriendlyError = (technicalError: string | null): string => {
  if (!technicalError) return '√ñdeme i≈ülemi ba≈üarƒ±sƒ±z oldu';
  
  const errorLower = technicalError.toLowerCase();
  
  // Common payment errors
  if (errorLower.includes('insufficient') || errorLower.includes('yetersiz') || errorLower.includes('balance')) {
    return 'üí≥ Kartƒ±nƒ±zda yetersiz bakiye bulunuyor. L√ºtfen farklƒ± bir kart deneyin.';
  }
  if (errorLower.includes('declined') || errorLower.includes('reddedildi') || errorLower.includes('reject')) {
    return 'üö´ Bankanƒ±z i≈ülemi reddetti. L√ºtfen bankanƒ±zla ileti≈üime ge√ßin.';
  }
  if (errorLower.includes('invalid card') || errorLower.includes('ge√ßersiz kart') || errorLower.includes('card number')) {
    return '‚ùå Kart bilgileri ge√ßersiz. L√ºtfen kart numaranƒ±zƒ± kontrol edin.';
  }
  if (errorLower.includes('expired') || errorLower.includes('s√ºresi dolmu≈ü') || errorLower.includes('expir')) {
    return 'üìÖ Kartƒ±nƒ±zƒ±n son kullanma tarihi ge√ßmi≈ü. L√ºtfen g√ºncel bir kart kullanƒ±n.';
  }
  if (errorLower.includes('cvc') || errorLower.includes('cvv') || errorLower.includes('g√ºvenlik kodu')) {
    return 'üîí G√ºvenlik kodu (CVC) hatalƒ±. L√ºtfen kartƒ±nƒ±zƒ±n arkasƒ±ndaki 3 haneli kodu kontrol edin.';
  }
  if (errorLower.includes('3d secure') || errorLower.includes('authentication') || errorLower.includes('doƒürulama')) {
    return 'üîê 3D Secure doƒürulamasƒ± ba≈üarƒ±sƒ±z. L√ºtfen SMS kodunu doƒüru girdiƒüinizden emin olun.';
  }
  if (errorLower.includes('limit') || errorLower.includes('exceed')) {
    return '‚ö†Ô∏è Kart limitiniz a≈üƒ±ldƒ±. L√ºtfen farklƒ± bir kart deneyin veya bankanƒ±zla g√∂r√º≈ü√ºn.';
  }
  if (errorLower.includes('timeout') || errorLower.includes('zaman a≈üƒ±mƒ±')) {
    return '‚è±Ô∏è ƒ∞≈ülem zaman a≈üƒ±mƒ±na uƒüradƒ±. L√ºtfen tekrar deneyin.';
  }
  if (errorLower.includes('blocked') || errorLower.includes('bloke') || errorLower.includes('frozen')) {
    return 'üîí Kartƒ±nƒ±z bloke edilmi≈ü. L√ºtfen bankanƒ±zla ileti≈üime ge√ßin.';
  }
  
  // Return original error if no match (but keep it user-friendly)
  return `‚ùå ${technicalError}`;
};

/**
 * Payment Callback Page
 * Handles 3D Secure redirect and payment verification
 */
const PaymentCallbackPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { user, initialize } = useAuthStore();
  
  const [status, setStatus] = useState<'processing' | 'success' | 'failure' | 'error'>('processing');
  const [message, setMessage] = useState('√ñdeme i≈üleminiz kontrol ediliyor...');
  const [transactionId, setTransactionId] = useState<string | null>(null);
  const [countdown, setCountdown] = useState<number | null>(null);

  useEffect(() => {
    // Check if this is a POST callback from ƒ∞yzico (will have form data in body)
    // Since we can't directly access POST data in frontend, we'll use query params
    // that ƒ∞yzico adds to the callback URL after successful 3D Secure
    handlePaymentCallback();
  }, [searchParams]);

  const handleSuccessfulPayment = async (txId: string | null, params: URLSearchParams) => {
    setStatus('success');
    setMessage('√ñdemeniz ba≈üarƒ±yla tamamlandƒ±! üéâ');
    if (txId) setTransactionId(txId);

    // Get plan details from sessionStorage
    const planData = sessionStorage.getItem('pending_payment');
    
    console.log('üì¶ SessionStorage pending_payment:', planData);
    
    if (planData && user) {
      const parsedData = JSON.parse(planData);
      const { planTier, billingPeriod, amount: planAmount } = parsedData;
      
      console.log('üí∞ Processing successful payment:', {
        userId: user.id,
        transactionId: txId,
        planTier,
        billingPeriod,
        planAmount,
        parsedData,
      });
      
      // Upgrade subscription
      await subscriptionService.upgradeSubscription(user.id, planTier, billingPeriod, txId || '');
      console.log('‚úÖ Subscription upgraded successfully');

      // Save payment history
      // Use amount from planData (sessionStorage) as fallback if URL doesn't have it
      const urlAmount = params.get('amount');
      const amount = urlAmount && parseFloat(urlAmount) > 0 
        ? parseFloat(urlAmount) 
        : planAmount;
      const currency = params.get('currency') || 'TRY';
      
      console.log('üíæ Saving payment history:', {
        amount,
        currency,
        planAmount,
        urlAmount,
        finalAmount: amount,
      });
      
      // Only save if amount is valid (> 0)
      if (amount && amount > 0) {
        await subscriptionService.savePaymentHistory(
          user.id,
          txId || '',
          params.get('providerTransactionId') || '',
          'iyzico',
          amount,
          currency,
          'SUCCESS',
          planTier,
          billingPeriod,
          `${planTier.toUpperCase()} - ${billingPeriod === 'monthly' ? 'Aylƒ±k' : 'Yƒ±llƒ±k'} Abonelik`
        );
        console.log('‚úÖ Payment history saved successfully');
      } else {
        console.error('‚ùå Payment history NOT saved - amount is 0 or invalid!', {
          amount,
          planAmount,
          urlAmount: params.get('amount'),
        });
        toast.error('√ñdeme kaydƒ± olu≈üturulamadƒ±. L√ºtfen destek ile ileti≈üime ge√ßin.');
      }

      // Clear pending payment
      sessionStorage.removeItem('pending_payment');
      sessionStorage.removeItem('last_transaction_id');

      // Refresh auth state
      await initialize();
    }

    // Start countdown and redirect to account page
    setCountdown(5);
    const countdownInterval = setInterval(() => {
      setCountdown(prev => {
        if (prev === null || prev <= 1) {
          clearInterval(countdownInterval);
          navigate('/account');
          return null;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const handleFailedPayment = async (txId: string | null, error: string | null) => {
    // Convert technical error to user-friendly message
    const userFriendlyError = getUserFriendlyError(error);
    
    setStatus('failure');
    setMessage(userFriendlyError);
    if (txId) setTransactionId(txId);
    
    toast.error(userFriendlyError);

    // Save failed payment to history with user-friendly error
    if (user) {
      const planData = sessionStorage.getItem('pending_payment');
      if (planData) {
        const { planTier, billingPeriod, amount: planAmount } = JSON.parse(planData);
        
        // Save with user-friendly error message
        await subscriptionService.savePaymentHistory(
          user.id,
          txId || '',
          '',
          'iyzico',
          planAmount || 0, // Use plan amount from sessionStorage
          'TRY',
          'FAILURE',
          planTier,
          billingPeriod,
          undefined,
          userFriendlyError // Save user-friendly error
        );
      }
      sessionStorage.removeItem('pending_payment');
      sessionStorage.removeItem('last_transaction_id');
    }

    // Start countdown and redirect to pricing
    setCountdown(5);
    const countdownInterval = setInterval(() => {
      setCountdown(prev => {
        if (prev === null || prev <= 1) {
          clearInterval(countdownInterval);
          navigate('/pricing');
          return null;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const handlePaymentCallback = async () => {
    try {
      // Development logging only
      if (import.meta.env.DEV) {
        console.log('üîç Payment callback started');
        console.log('üìç Current URL:', window.location.href);
        console.log('üì¶ URL Search Params:', Array.from(searchParams.entries()));
      }
      
      // Backend proxy'den gelen parametreler (priority)
      const success = searchParams.get('success');
      const statusParam = searchParams.get('status');
      const errorParam = searchParams.get('error');
      
      // Transaction ID - backend'den veya sessionStorage'dan
      let txId = searchParams.get('transactionId') || 
                 searchParams.get('transaction_id') ||
                 sessionStorage.getItem('last_transaction_id');
      
      console.log('üîç Transaction ID:', txId);
      console.log('‚úÖ Success param:', success);
      console.log('üìä Status param:', statusParam);
      console.log('‚ùå Error param:', errorParam);
      
      // Backend'den direkt sonu√ß geldi mi?
      if (success !== null) {
        if (success === 'true') {
          // Backend ba≈üarƒ±lƒ± dedi, direkt i≈üle
          console.log('‚úÖ Payment successful (from backend callback)');
          await handleSuccessfulPayment(txId, searchParams);
          return;
        } else {
          // Backend ba≈üarƒ±sƒ±z dedi
          console.log('‚ùå Payment failed (from backend callback)');
          await handleFailedPayment(txId, errorParam);
          return;
        }
      }
      
      // Fallback: Transaction ID yoksa sessionStorage'dan al
      if (!txId) {
        const pendingPayment = sessionStorage.getItem('pending_payment');
        console.log('üì¶ Pending payment:', pendingPayment);
        
        if (pendingPayment) {
          setStatus('processing');
          setMessage('√ñdeme i≈üleminiz kontrol ediliyor...');
          console.log('‚è≥ No transaction ID yet, retrying in 2 seconds...');
          setTimeout(() => {
            handlePaymentCallback();
          }, 2000);
          return;
        } else {
          console.error('‚ùå No transaction ID found!');
          setStatus('error');
          setMessage('ƒ∞≈ülem kimliƒüi bulunamadƒ±. L√ºtfen hesap sayfanƒ±zdan √∂deme durumunu kontrol edin.');
          return;
        }
      }

      setTransactionId(txId);

      // Check payment status
      const result = await paymentService.checkPaymentStatus(txId);

      if (result.success && result.status === 'SUCCESS') {
        // Payment successful
        setStatus('success');
        setMessage('√ñdemeniz ba≈üarƒ±yla tamamlandƒ±! üéâ');

        // Get plan details from transaction ID or session storage
        const planData = sessionStorage.getItem('pending_payment');
        if (planData && user) {
          const { planTier, billingPeriod, amount: planAmount } = JSON.parse(planData);
          
          // Upgrade subscription
          await subscriptionService.upgradeSubscription(
            user.id,
            planTier,
            billingPeriod,
            txId
          );

          // Save payment to history
          // Use amount from result if available, fallback to planAmount
          const paymentAmount = result.amount || planAmount || 0;
          
          if (paymentAmount > 0) {
            await subscriptionService.savePaymentHistory(
              user.id,
              txId,
              result.transactionId,
              'iyzico',
              paymentAmount,
              result.currency || 'TRY',
              'SUCCESS',
              planTier,
              billingPeriod,
              `${planTier.toUpperCase()} - ${billingPeriod === 'monthly' ? 'Aylƒ±k' : 'Yƒ±llƒ±k'} Abonelik`
            );
          }

          // Clear pending payment and transaction ID
          sessionStorage.removeItem('pending_payment');
          sessionStorage.removeItem('last_transaction_id');

          // Refresh auth state to get updated subscription
          await initialize();
        }

        // Redirect to dashboard after 3 seconds
        setTimeout(() => {
          navigate('/dashboard');
        }, 3000);

      } else if (result.status === 'FAILURE') {
        // Payment failed
        setStatus('failure');
        setMessage(result.errorMessage || '√ñdeme i≈ülemi ba≈üarƒ±sƒ±z oldu');
        
        toast.error('√ñdeme ba≈üarƒ±sƒ±z! L√ºtfen tekrar deneyin.');

        // Save failed payment to history
        if (user) {
          const planData = sessionStorage.getItem('pending_payment');
          if (planData) {
            const { planTier, billingPeriod, amount: planAmount } = JSON.parse(planData);
            
            // Use amount from result if available, fallback to planAmount
            const paymentAmount = result.amount || planAmount || 0;
            
            await subscriptionService.savePaymentHistory(
              user.id,
              txId,
              result.transactionId,
              'iyzico',
              paymentAmount,
              result.currency || 'TRY',
              'FAILURE',
              planTier,
              billingPeriod,
              undefined,
              result.errorMessage
            );
          }
          sessionStorage.removeItem('pending_payment');
          sessionStorage.removeItem('last_transaction_id');
        }

        // Redirect to pricing after 5 seconds
        setTimeout(() => {
          navigate('/pricing');
        }, 5000);

      } else if (result.status === 'PENDING' || result.status === 'WAITING_3D') {
        // Still processing
        setStatus('processing');
        setMessage('√ñdeme i≈üleminiz hala devam ediyor. L√ºtfen bekleyin...');
        
        // Retry after 3 seconds
        setTimeout(() => {
          handlePaymentCallback();
        }, 3000);

      } else {
        // Unknown status
        setStatus('error');
        setMessage('Beklenmeyen bir durum olu≈ütu. L√ºtfen destek ile ileti≈üime ge√ßin.');
      }

    } catch (error: any) {
      console.error('‚ùå Payment callback error:', error);
      setStatus('error');
      setMessage('√ñdeme kontrol√º sƒ±rasƒ±nda bir hata olu≈ütu');
      toast.error('Bir hata olu≈ütu. L√ºtfen destek ile ileti≈üime ge√ßin.');
    }
  };

  const getIcon = () => {
    switch (status) {
      case 'processing':
        return <Loader2 className="h-20 w-20 text-blue-500 animate-spin" />;
      case 'success':
        return <CheckCircle className="h-20 w-20 text-green-500" />;
      case 'failure':
        return <XCircle className="h-20 w-20 text-red-500" />;
      case 'error':
        return <AlertCircle className="h-20 w-20 text-orange-500" />;
    }
  };

  const getStatusColor = () => {
    switch (status) {
      case 'processing':
        return 'text-blue-600';
      case 'success':
        return 'text-green-600';
      case 'failure':
        return 'text-red-600';
      case 'error':
        return 'text-orange-600';
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-2xl shadow-xl max-w-md w-full p-8 text-center">
        {/* Icon */}
        <div className="flex justify-center mb-6">
          {getIcon()}
        </div>

        {/* Status Message */}
        <h1 className={`text-2xl font-bold mb-4 ${getStatusColor()}`}>
          {status === 'processing' && 'ƒ∞≈ülem Devam Ediyor'}
          {status === 'success' && '√ñdeme Ba≈üarƒ±lƒ±!'}
          {status === 'failure' && '√ñdeme Ba≈üarƒ±sƒ±z'}
          {status === 'error' && 'Bir Hata Olu≈ütu'}
        </h1>

        <p className="text-gray-600 mb-6">{message}</p>

        {/* Transaction ID */}
        {transactionId && (
          <div className="bg-gray-50 rounded-lg p-4 mb-6">
            <p className="text-xs text-gray-500 mb-1">ƒ∞≈ülem Numarasƒ±</p>
            <p className="text-sm font-mono text-gray-700 break-all">{transactionId}</p>
          </div>
        )}

        {/* Countdown */}
        {countdown !== null && countdown > 0 && (
          <div className="mb-6">
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <p className="text-sm text-blue-800 text-center">
                {status === 'success' ? 'Hesap sayfasƒ±na' : 'Fiyatlandƒ±rma sayfasƒ±na'} y√∂nlendiriliyorsunuz...
              </p>
              <p className="text-2xl font-bold text-blue-600 text-center mt-2">
                {countdown}
              </p>
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="space-y-3">
          {status === 'success' && (
            <button
              onClick={() => navigate('/account')}
              className="w-full btn-primary"
            >
              Hesabƒ±ma Git
            </button>
          )}

          {status === 'failure' && (
            <button
              onClick={() => navigate('/pricing')}
              className="w-full btn-primary"
            >
              Tekrar Dene
            </button>
          )}

          {status === 'error' && (
            <>
              <button
                onClick={() => navigate('/pricing')}
                className="w-full btn-primary"
              >
                Fiyatlandƒ±rmaya D√∂n
              </button>
              <button
                onClick={() => navigate('/account')}
                className="w-full btn-outline"
              >
                Hesabƒ±ma Git
              </button>
            </>
          )}

          {status !== 'processing' && (
            <p className="text-xs text-gray-500 mt-4">
              Sorun ya≈üƒ±yorsanƒ±z, l√ºtfen <a href="mailto:destek@davetim.app" className="text-primary-600 hover:underline">destek@davetim.app</a> ile ileti≈üime ge√ßin.
            </p>
          )}
        </div>
      </div>
    </div>
  );
};

export default PaymentCallbackPage;

